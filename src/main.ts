import { Plugin } from "obsidian";
import { RangeSetBuilder } from "@codemirror/rangeset";
import { EditorView, Decoration, DecorationSet, ViewUpdate, WidgetType, ViewPlugin } from "@codemirror/view";
import { EditorState, EditorSelection, TransactionSpec } from "@codemirror/state";
import { syntaxTree } from "@codemirror/language";
import { tokenClassNodeProp } from "@codemirror/stream-parser";
import { foldable } from "@codemirror/language";
import { foldEffect, unfoldEffect, foldedRanges } from "@codemirror/fold";

export default class AttributesPlugin extends Plugin {
  async onload() {
    const ext = this.buildAttributesViewPlugin();
    this.registerEditorExtension(ext);
  }

  buildAttributesViewPlugin() {
    // build the DOm element that we'll prepend to list elements
    class FoldWidget extends WidgetType {
      isFolded: boolean;

      constructor(isFolded: boolean) {
        super();
        this.isFolded = isFolded;
      }

      eq(other: FoldWidget) {
        return other.isFolded == this.isFolded;
      }

      toDOM() {
        let el = document.createElement("span");
        el.className = "cm-list-widget";
        el.textContent = this.isFolded ? "▸" : "▾";
        return el;
      }

      ignoreEvent() {
        return false;
      }
    }

    const viewPlugin = ViewPlugin.fromClass(
      class {
        decorations: DecorationSet;
        lineCache: {}; // TODO: Implement caching
        tokenCache: {}; // TODO: Implement caching

        constructor(view: EditorView) {
          this.decorations = this.buildDecorations(view);
        }

        update(update: ViewUpdate) {
          if (update.docChanged || update.viewportChanged) {
            this.decorations = this.buildDecorations(update.view);
          } else if (update.geometryChanged) {
            // this logic is to update the fold widget icons since a fold
            // does not trigger docChanged or viewportChanged
            // there's probably a better way to do this
            for (let tr of update.transactions) {
              for (let effect of tr.effects) {
                if (effect && effect.value) {
                  if (effect.is(foldEffect) || effect.is(unfoldEffect)) {
                    this.decorations = this.buildDecorations(update.view);
                  }
                }
              }
            }
          }
        }

        destroy() {}

        buildDecorations(view: EditorView) {
          const hashTagRegexp = /#(?:[^\u2000-\u206F\u2E00-\u2E7F'!"#$%&()*+,.:;<=>?@^`{|}~\[\]\\\s])+/g;
          let builder = new RangeSetBuilder<Decoration>();
          // use view.visibleRanges rather than view.viewPort since visibleRanges will filter out folded and non visible ranges
          for (let { from, to } of view.visibleRanges) {
            try {
              // syntaxTree gives us access to the tokens generated by the markdown parser
              // here we iterate over the visible text and evaluate each token, sequentially.
              syntaxTree(view.state).iterate({
                from,
                to,
                enter: (type, from, to) => {
                  // To access the parsed tokens, we need to use a NodeProp.
                  // Obsidian exports their inline token NodeProp, tokenClassNodeProp, as part of their
                  // custom stream-parser package. See the readme for more details.

                  const tokenProps = type.prop(tokenClassNodeProp);

                  if (tokenProps) {
                    const props = new Set(tokenProps.split(" "));
                    const isTag = props.has("hashtag-end");
                    const isList = props.has("formatting-list");
                    const isHeader = props.has("formatting-header");
                    const isBarelink = props.has("hmd-barelink") && !props.has("formatting");

                    if (isList || isHeader) {
                      // add a fold icon, inline, next to every foldable list item
                      // TODO: fix the naive negative margin in styles.css
                      let range,
                        line = view.state.doc.lineAt(from);
                      if ((range = foldable(view.state, line.from, line.to))) {
                        const isFolded = foldExists(view.state, range.from, range.to);
                        let deco = Decoration.widget({
                          widget: new FoldWidget(isFolded),
                        });
                        builder.add(from, from, deco);
                      }
                    }
                    if (isTag) {
                      // This adds a data-tags attribute to the parent cm-line.
                      // The attribute value will be a list of all tags found on the line
                      // TODO: this currently recomputes the entire list of hashtags for a given
                      // line once for every hashtag found. it works but it could be better.
                      let line = view.state.doc.lineAt(from);
                      let deco = Decoration.line({
                        attributes: { "data-tags": line.text.match(hashTagRegexp)?.join(" ").replace(/#/g, "") },
                      });
                      // TODO: Figure out a better way to fix the pos conflict when
                      //       a top level list item has a hashtag at the beginning of the line
                      // The code below is a hack using internal class properties
                      if ((<any>builder).lastFrom == line.from) {
                        // if we don't do this, we get an error stating our rangeset is not sorted
                        deco.startSide = (<any>builder).last.startSide + 1;
                      }
                      builder.add(line.from, line.from, deco);
                    }
                    if (isBarelink) {
                      // add the value of barelinks as an href on the inline element
                      // this will cause a nested span to be created
                      let deco = Decoration.mark({
                        attributes: { href: view.state.doc.sliceString(from, to) },
                      });
                      builder.add(from, to, deco);
                    }
                  }
                },
              });
            } catch (err) {
              // cm6 will silently unload extensions when they crash
              // this try/catch will provide details when crashes occur
              console.error("Custom CM6 view plugin failure", err);
              // make to to throw because if you don't, you'll block
              // the auto unload and destabilize the editor
              throw err;
            }
          }
          return builder.finish();
        }
      },
      {
        decorations: v => v.decorations,

        eventHandlers: {
          // create an event handler for our new fold widget
          mousedown: (e, view) => {
            // TODO: move the cursor to the end of the folded range
            let target = e.target as HTMLElement;
            if (target.nodeName == "SPAN" && target.classList.contains("cm-list-widget")) {
              const foldMarkerPos = view.posAtDOM(target);
              const line = view.state.doc.lineAt(foldMarkerPos);
              let range = foldable(view.state, line.from, line.to);
              if (range) {
                let curPos = view.state.selection.main.head;
                let effect = foldExists(view.state, range.from, range.to) ? unfoldEffect : foldEffect;
                let transaction: TransactionSpec = { effects: [effect.of(range), announceFold(view, range)] };
                if (curPos > range.from && curPos < range.to) {
                  transaction.selection = EditorSelection.cursor(range.to);
                }
                view.dispatch(transaction);
                return true;
              }
            }
          },
        },
      }
    );

    return viewPlugin;
  }
}

function foldExists(state: EditorState, from: number, to: number) {
  // adapted from https://github.com/codemirror/fold/blob/36ca2ec57aa3907fb0d1c13669b51e98e379e583/src/fold.ts#L76
  const folded = foldedRanges(state);
  let found = false;
  folded.between(from, from, (a, b) => {
    if (a == from && b == to) found = true;
  });
  return found;
}

function announceFold(view: EditorView, range: { from: number; to: number }, fold = true) {
  // copied from https://github.com/codemirror/fold/blob/36ca2ec57aa3907fb0d1c13669b51e98e379e583/src/fold.ts#L110
  let lineFrom = view.state.doc.lineAt(range.from).number,
    lineTo = view.state.doc.lineAt(range.to).number;
  return EditorView.announce.of(
    `${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`
  );
}
